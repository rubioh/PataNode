from artnet.packet.base import ArtOp, ArtBase, ArtParseError

from bytechomp import dataclass, Parser
from bytechomp.datatypes.declarations import U8


@dataclass(frozen=True)
class ArtDmxPayload:
    # The sequence number is used to ensure that ArtDmx packets are used in the correct order.
    # When Art-Net is carried over a medium such as the Internet, it is possible
    # that ArtDmx packets will reach the receiver out of order.  This field is
    # incremented in the range 0x01 to 0xff to allow the receiving node to re-sequence packets.
    # The Sequence field is set to 0x00 to disable this feature.
    sequence: U8

    # The physical input port from which DMX512
    # data was input. This field is used by the receiving device to discriminate between
    # packets with identical Port-Address that have
    # been generated by different input ports and so
    # need to be merged.
    physical: U8

    # The low byte of the 15 bit Port-Address to
    # which this packet is destined.
    sub_uni: U8

    # The top 7 bits of the 15 bit Port-Address to
    # which this packet is destined.
    net: U8

    # The length of the DMX512 data array. This
    # value should be an even number in the range 2 â€“ 512.
    # It represents the number of DMX512 channels
    # encoded in packet. NB: Products which convert
    # Art-Net to DMX512 may opt to always send 512
    # channels.
    length_hi: U8

    # Low byte of above
    length: U8


class ArtDmx(ArtBase[ArtDmxPayload]):
    _parser = Parser[ArtDmxPayload]().build()
    op_code = ArtOp.DMX
    data: bytes

    @staticmethod
    def new(
        data: bytes,
        sub_uni: int,
        net: int,
        sequence: int = 0,
        physical: int = 0,
    ) -> "ArtDmx":
        assert 2 <= len(data) <= 512 and len(data) % 2 == 0
        length_hi = len(data) >> 8
        length_low = len(data) & 0xFF
        return ArtDmx(
            payload=ArtDmxPayload(
                U8(sequence & 0xFF),
                U8(physical),
                U8(sub_uni),
                U8(net),
                U8(length_hi),
                U8(length_low),
            ),
            extra=data,
        )

    @staticmethod
    def validate(data: ArtDmxPayload, extra: bytes) -> None:
        length = 2**8 * data.length_hi + data.length

        if not 2 <= length <= 512:
            raise ArtParseError(f"artdmx data length is out of range: {length}")
        elif len(extra) < length:
            raise ArtParseError(
                f"artdmx data expected length was {len(extra)} but there are only {length} bytes"
            )
        elif length % 2:
            print("warning: artdmx data length should be even but it is {length}")
